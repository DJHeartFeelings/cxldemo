1.
hibernate查询缓存  http://xuzhanxi.iteye.com/blog/298218
查询缓存是针对普通属性结果集的缓存，对实体对象的结果集只缓存id 

查询缓存的生命周期，当前关联的表发生修改，那么查询缓存生命周期结束 
查询缓存的配置和使用： 
* 在hibernate.cfg.xml文件中启用查询缓存，如： 
<property name="hibernate.cache.use_query_cache">true</property> 
* 在程序中必须手动启用查询缓存，如： 
query.setCacheable(true); 
         查询缓存的生命周期和session无关 
          查询缓存只对query.list()起作用，query.iterate不起作用，也就是query.iterate不使用查询缓存 



2.
WebApplicationContext context = RequestContextUtils
				.getWebApplicationContext(request);
RequestContextUtils.getWebApplicationContext这个方法， 返回request.getAttribute(DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE);
而WEB_APPLICATION_CONTEXT_ATTRIBUTE其实就是DispatcherServlet.class.getName() + ".CONTEXT"。
注意，如果配置了不同的DispatcherServlet，返回的WebApplicationContext实例是不同的。

RequestContextUtils.getLocaleResolver(request);也同理去获得request.getAttribute（
DispatcherServlet.class.getName() + ".LOCALE_RESOLVER"）


3.级联删除问题。
栏目c的浏览权限引用了某个会员组g，因为g配置了inverse="true"(inverse="false"是默认值)，删除g必先级联删除关联，如（CmsGroupMngImpl.deleteById）改为以下代码：
	public CmsGroup deleteById(Integer id) {
		CmsGroup bean =  dao.findById(id);
		
//		bean.getViewChannels().remove(bean);
//		for(Channel chanel : bean.getViewChannels()){
//			chanel.getViewGroups().remove(bean);
//		}
		dao.deleteById(id);
		return bean;
	}
如果删除c，其实可以直接删除即可。不必写出如下代码（ChannelMngImpl.deleteById）：
	public Channel deleteById(Integer id) {
		Channel entity = dao.findById(id);
		for (CmsGroup group : entity.getViewGroups()) {
			group.getViewChannels().remove(entity);
		}
		for (CmsGroup group : entity.getContriGroups()) {
			group.getContriChannels().remove(entity);
		}
		entity = dao.deleteById(id);
		return entity;
	}。

4.删除包含某个标签t的内容c，t的内容计数减1，代码如何体现？以下（ContentTagMngImpl.removeTags），传入的tags参数是集合引用，带密码里面tag.setCount(tag.getCount() - 1);
之后，hibernate应该会检测到数据的变化，把tags也持久化，就实现减1了。
	public void removeTags(Collection<ContentTag> tags) {
		Set<ContentTag> toRemove = new HashSet<ContentTag>();
		for (ContentTag tag : tags) {
			tag.setCount(tag.getCount() - 1);
			if (tag.getCount() <= 0) {
				toRemove.add(tag);
			}
		}
		for (ContentTag tag : toRemove) {
			//由于事务真正删除关联的sql语句还没有执行，这个时候jc_contenttag里至少还有一条数据。
			if (dao.countContentRef(tag.getId()) <= 1) {
				dao.deleteById(tag.getId());
			} else {
				// 还有引用，不应该出现的情况，此时无法删除。
				log.warn("ContentTag ref to Content > 1,"
						+ " while ContentTag.ref_counter <= 0");
			}
		}
	}